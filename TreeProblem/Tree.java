package TreeProblem;

public class Tree {
    
}

// 重直遍歷
// 不同的 BST
// BST刪除
// 法1
// #从「当前节点的左子树」中选择「值最大」root.left找最右邊的節點 while (t.right != null) t = t.right;
// 把右子樹掛給當前指針 t.right = root.right;
// 回傳root.left
// 法2
// #从「当前节点的右子树」中选择「值最小」的节点替代
// 路径总和 II 分解子問題的思路
// 同257所有可能路徑
// https://leetcode.cn/problems/binary-tree-paths/solutions/400434/257-er-cha-shu-de-suo-you-lu-jing-tu-wen-jie-xi-by/

// https://leetcode.cn/problems/path-sum-ii/solutions/427844/3chong-fang-shi-jie-jue-2chong-ji-bai-liao-100de-2/

// $$$
// 路徑總和系列 I/II/III
// 543. 二叉树的直径
// 124. 二叉树中的最大路径和
// $$$

// $$$
// 行操作
// 662. 二叉树最大宽度
// $$$
